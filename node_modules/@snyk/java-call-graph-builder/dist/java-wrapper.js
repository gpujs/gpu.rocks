"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
require("source-map-support/register");
const jszip = require("jszip");
const path = require("path");
const config = require("./config");
const sub_process_1 = require("./sub-process");
const fetch_snyk_java_call_graph_generator_1 = require("./fetch-snyk-java-call-graph-generator");
const call_graph_1 = require("./call-graph");
const promisified_fs_glob_1 = require("./promisified-fs-glob");
const class_parsing_1 = require("./class-parsing");
const metrics_1 = require("./metrics");
function getCallGraphGenCommandArgs(classPath, jarPath, entrypoints) {
    return [
        '-cp',
        jarPath,
        'io.snyk.callgraph.app.App',
        '--application-classpath',
        classPath,
        '--classes-to-get-entrypoints',
        entrypoints.join(','),
    ];
}
function runJavaCommand(javaCommandArgs, targetPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return sub_process_1.execute('java', javaCommandArgs, { cwd: targetPath });
    });
}
function getEntrypoints(targetPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const targetDirs = yield promisified_fs_glob_1.glob(path.join(targetPath, '**/target'));
        if (!targetDirs.length) {
            throw new Error('Could not find a target folder');
        }
        const entrypointsFiles = yield promisified_fs_glob_1.glob(path.join(targetPath, '**/target/classes/**/*.class'));
        return entrypointsFiles.map((entrypoint) => entrypoint
            .split('target/classes/')[1]
            .replace('.class', '')
            // Some build paths also include "java/main/" or "main/, which is not part of the class name
            .replace(/(^java\/main\/)|(^main\/)/, ''));
    });
}
exports.getEntrypoints = getEntrypoints;
function getClassPerJarMapping(classPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const classPerJarMapping = {};
        for (const classPathItem of classPath.split(':')) {
            // classpath can also contain local directories with classes - we don't need them for package mapping
            if (!classPathItem.endsWith('.jar')) {
                continue;
            }
            const jarFileContent = yield promisified_fs_glob_1.readFile(classPathItem);
            const jarContent = yield jszip.loadAsync(jarFileContent);
            for (const classFile of Object.keys(jarContent.files).filter((name) => name.endsWith('.class'))) {
                const className = class_parsing_1.toFQclassName(classFile.replace('.class', '')); // removing .class from name
                classPerJarMapping[className] = classPathItem;
            }
        }
        return classPerJarMapping;
    });
}
exports.getClassPerJarMapping = getClassPerJarMapping;
function getCallGraph(classPath, targetPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const jarPath = yield fetch_snyk_java_call_graph_generator_1.fetch(config.CALL_GRAPH_GENERATOR_URL, config.CALL_GRAPH_GENERATOR_CHECKSUM);
        const entrypoints = yield metrics_1.timeIt('getEntrypoints', () => getEntrypoints(targetPath));
        if (!entrypoints.length) {
            throw new Error('No entrypoints found');
        }
        const callgraphGenCommandArgs = getCallGraphGenCommandArgs(classPath, jarPath, entrypoints);
        try {
            const javaOutput = yield metrics_1.timeIt('generateCallGraph', () => runJavaCommand(callgraphGenCommandArgs, targetPath));
            const classPerJarMapping = yield metrics_1.timeIt('mapClassesPerJar', () => getClassPerJarMapping(classPath));
            return call_graph_1.buildCallGraph(javaOutput, classPerJarMapping);
        }
        catch (e) {
            throw new Error(`java command 'java ${callgraphGenCommandArgs.join(' ')} failed with error: ${e}`);
        }
    });
}
exports.getCallGraph = getCallGraph;
//# sourceMappingURL=java-wrapper.js.map